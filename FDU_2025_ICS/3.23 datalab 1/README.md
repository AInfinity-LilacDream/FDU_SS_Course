# 俞楚凡 ICS DataLab 1

`bitXor`

使用德摩根律实现。可以将or转换为and。

`tmin`

自然溢出1即可。

`isTmax`

最大值+最小值+1=0. -1同样满足此约定，因此特判-1。

`allOddBits`

`0xAA`是一个典型的偶数位全为1的数。先构造出0xAAAAAAAA，再以此作为蒙版即可。

`negate`

推公式可得。

`isAsciiDigit`

根据0x30 - 0x39的二进制特征，把特定位数拆出来看就好了。

`conditional`

把x转为0/0xFFFFFFFF，再用其对两个数字分别蒙版，或起来返回，可以得到二选一的效果。

`isLessOrEqual`

分情况讨论：同号相减不会溢出，直接减；异号相减会溢出，直接判断y是不是正数即可。最后利用`conditional`的结论返回就可以。

`logicalNeg`

推式子可得。

`howManyBits`

对于正数判断前导1，负数判断前导0即可。实际实现的时候将负数转为正数来算。随后二分的判断，前导1是否在高x位：是则把低位砍掉继续判断高位；否则判断低位。

`floatScale2`

分离出三个部分。随后分规格化数和非规格化数进行讨论。规格化直接指数+1即可；非规格化，NaN直接输出NaN，指数为0则判断是否二倍之后变1，是的话exp+1 frac不动，不是的话exp不动。

`floatFloat2Int`

分离出三个部分；随后分情况讨论。重点在于规格化数，计算实际的E之后变换指数，最后根据sign变换结果。

`floatPower2`

直接根据指数部分讨论即可。太大输出NaN，太小输出0，其余部分直接按照题意返回。